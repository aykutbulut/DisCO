#include "DcoLinearConGenerator.hpp"
#include "DcoModel.hpp"
#include "DcoMessage.hpp"
#include "DcoLinearConstraint.hpp"

#include <CglCutGenerator.hpp>
#include <CglProbing.hpp>

/// Useful constructor.
DcoLinearConGenerator::DcoLinearConGenerator(DcoModel * model,
                        CglCutGenerator * generator,
                        DcoConstraintType type,
                        char const * name ,
                        DcoCutStrategy strategy,
                        int frequency):
  DcoConGenerator(model, type, name, strategy, frequency) {
  generator_ = generator;
}

/// Destructor.
DcoLinearConGenerator::~DcoLinearConGenerator() {
  delete generator_;
}

/// Generate constraints and add them to the pool.  return true if resolve is
/// needed (because the state of the solver interface has been modified).
bool DcoLinearConGenerator::generateConstraints(BcpsConstraintPool & conPool) {
  // get necessary objects for logging messages
  CoinMessageHandler * message_handler = model()->dcoMessageHandler_;
  //CoinMessages * messages = model()->dcoMessages_;

  // check whether we have a CGL generator
  if (generator_==NULL) {
    message_handler->message(9998, "Dco", "Linear cut generator has no"
                             " Cgl generator.",
                             'E', 0)
      << CoinMessageEol;
  }

  // stop if cut strategy is auto and this generator did not perform well
  if (strategy() == DcoCutStrategyAuto) {
    int dis = model()->dcoPar()->entry(DcoParams::cutDisable);
    if (stats().numNoConsCalls()>dis) {
      return false;
    }
  }

  OsiCuts new_cuts;

  // we can not handle probing yet.
  CglProbing * generator = dynamic_cast<CglProbing *>(generator_);
  if (generator) {
    message_handler->message(3000, "Dco",
                             "Probing cut generator is not "
                             "implemented yet. Skipping cut "
                             "generation.",
                             'W', 0)
      << CoinMessageEol;
  }
  else {
    // need to refresh solver
    // store generator type in a class member (DcoLinearCutType)
    generator_->refreshSolver(model()->solver());
    generator_->generateCuts(*model()->solver(), new_cuts);
  }



  // create disco constraints
  int num_cuts = new_cuts.sizeRowCuts();
  for (int i=0; i<num_cuts; ++i) {
    OsiRowCut & rcut = new_cuts.rowCut(i);
    int len = rcut.row().getNumElements();
    int const * ind = rcut.row().getIndices();
    double const * val = rcut.row().getElements();
    double lb = rcut.lb();
    double ub = rcut.ub();
    if (len > 0) {
      // create DcoConstraints from OsiCuts.
      DcoConstraint * con = new DcoLinearConstraint(len, ind, val, lb, ub);
      con->setConstraintType(type());
      conPool.addConstraint(con);
    }
    else if (len==0) {
      // Empty cuts
      std::stringstream msg;
      msg << "Skipping empty cut generated by "
          << name();
      message_handler->message(3000, "Dco", msg.str().c_str(), 'W', 0)
        << CoinMessageEol;
    }
    else {
      std::stringstream msg;
      msg << "Negative cut length given by "
          << name();
      message_handler->message(9998, "Dco", msg.str().c_str(), 'E', 0)
        << CoinMessageEol;
    }
  }
  return false;
}
